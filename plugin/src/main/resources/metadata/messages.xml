<?xml version="1.0" encoding="UTF-8"?>
<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:noNamespaceSchemaLocation="https://findbugs.googlecode.com/svn-history/r13419/trunk/findbugs/etc/messagecollection.xsd">

    <Plugin>
        <ShortDescription>Find Security Bugs</ShortDescription>
        <Details>Highlight part of the source code that should be analyze in a security audit.
        </Details>
    </Plugin>

    <!-- Predictable Pseudo Random Generator (PRG) -->
    <Detector class="com.h3xstream.findsecbugs.PredictableRandomDetector">
        <Details>Detect the use of predictable Pseudo Random Generator (PRG).
        </Details>
    </Detector>

    <BugPattern type="PREDICTABLE_RANDOM">
        <ShortDescription>Predictable Pseudo Random Generator (PRG)</ShortDescription>
        <LongDescription>Use of {3} is predictable.</LongDescription>
        <Details>
            <![CDATA[
<p>The use of a predictable random value can lead to vulnerability in those contexts:</p>
<ul>
<li>CSRF token</li>
<li>password reset token (sent by email)</li>
<li>or any other secret value</li>
</ul>
<p>A quick fix would be to replace the instanciation of <b>java.util.Random</b> by <b>java.security.SecureRandom</b>.

<p>
<b>References</b><br/>
<a href="http://jazzy.id.au/default/2010/09/20/cracking_random_number_generators_part_1.html">Cracking Random Number Generators - Part 1 (http://jazzy.id.au)</a><br/>
<a href="https://www.securecoding.cert.org/confluence/display/java/MSC02-J.+Generate+strong+random+numbers">CERT: MSC02-J. Generate strong random numbers</a><br/>
<a href="http://cwe.mitre.org/data/definitions/330.html">CWE-330: Use of Insufficiently Random Values</a>
</p>

]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECPR">Predictable Pseudo Random Generator (PRG)</BugCode>

    <!-- Servlet parameter -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.ServletEndpointDetector">
        <Details>Identify the unfilter value coming from ServletRequest and HttpServletRequest.
        </Details>
    </Detector>

    <BugPattern type="SERVLET_PARAMETER">
        <ShortDescription>Servlet parameter</ShortDescription>
        <LongDescription>The method {3} return a String value that is control by the client.</LongDescription>
        <Details>
            <![CDATA[
<p>The Servlet can read GET and POST parameters from various method. The value obtain should be consider unsafe.
In may be needed to sanitize those values when calling sensitive api such as:</p>
<ul>
<li>SQL query (May lead to SQL injection)</li>
<li>File opening (May lead to path traversal)</li>
<li>Command execution (Potential Command injection)</li>
<li>HTML construction (Potential XSS)</li>
<li>etc...</li>
</ul>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSP">Request parameter</BugCode>

    <BugPattern type="SERVLET_CONTENT_TYPE">
        <ShortDescription>Request Content-Type</ShortDescription>
        <LongDescription>The HTTP header Content-Type can be control by the client.</LongDescription>
        <Details>
            <![CDATA[
The HTTP header Content-Type can be control by the client.
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSCT">Request Content-Type</BugCode>


    <BugPattern type="SERVLET_SERVER_NAME">
        <ShortDescription>Request Hostname (ServerName/Host)</ShortDescription>
        <LongDescription>The hostname received can often be control by the client.</LongDescription>
        <Details>
            <![CDATA[
<p>The hostname can often be control by the client. Both <code>ServletRequest.getServerName()</code> and
<code>HttpServletRequest.getHeader("Host")</code> have the same behavior which is to extract the <code>Host</code> header.</p>
<pre>
GET /testpage HTTP/1.1
Host: www.example.com
[...]
</pre>
<p>
The web container serving your application may redirect requests to your application by default. This would allow
a malicious user to place any value. It is recommended to have no assumption on the value and therefor to do proper
escaping and validation if needed.
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSSN">Request Server Name (Hostname)</BugCode>


    <BugPattern type="SERVLET_SESSION_ID">
        <ShortDescription>Request Session Id</ShortDescription>
        <LongDescription>Request Session Id</LongDescription>
        <Details>
            <![CDATA[
<p>
The method <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRequestedSessionId()"><code>HttpServletRequest.getRequestedSessionId()</code></a>
typically return the value of the cookie <code>JSESSIONID</code>.
</p>
<p>
The value pass to the client is generally an alphanumeric value (ie: <code>JSESSIONID=jp6q31lq2myn</code>). However the value can be altered by the client. The following HTTP request illustrate the potential deviation.
<pre>
GET /somePage HTTP/1.1
Host: yourwebsite.com
User-Agent: Mozilla/5.0
Cookie: JSESSIONID=Get ready to receive any value!!??'''&quot;&gt;
</pre>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSSID">Request Session Id</BugCode>

    <BugPattern type="SERVLET_QUERY_STRING">
        <ShortDescription>Request Query String</ShortDescription>
        <LongDescription>The query string can be any value.</LongDescription>
        <Details>
            <![CDATA[
<p>The query string is the concatenation of the GET parameters and values. Parameter others that those intended can
be passed.</p>
<p>For the url request <code>/app/servlet.htm?a=1&b=2</code>, the query string extract will be <code>a=1&b=2</code></p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSSQ">Request Query String</BugCode>


    <BugPattern type="SERVLET_HEADER">
        <ShortDescription>Request Header</ShortDescription>
        <LongDescription>Request header can easily be alter by the client</LongDescription>
        <Details>
            <![CDATA[
<p>Request headers can easily be alter by the client. No assumption should be make that the request come from a regular browser.</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSH">Request Header</BugCode>


    <BugPattern type="SERVLET_HEADER_REFERER">
        <ShortDescription>Request Header "Referer"</ShortDescription>
        <LongDescription>The header "Referer" can be easily spoofed by the client.</LongDescription>
        <Details>
            <![CDATA[
<p>
Behavior:
<ul>
<li>Any value can be assigned to this header (request coming from malicious user)</li>
<li>The "Referer" will not be present if the request was initiated from another origin that is secure (https).</li>
</ul>
</p>
<p>
Recommendations:
<ul>
<li>No access control should be base on this header.</li>
<li>No CSRF protection should be based only on this value (<a href="http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14">Because it is optional</a>).</li>
</ul>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSHR">Request Header "Referer"</BugCode>

    <BugPattern type="SERVLET_HEADER_USER_AGENT">
        <ShortDescription>Request Header "User-Agent"</ShortDescription>
        <LongDescription>The header "User-Agent" can be easily spoofed by the client.</LongDescription>
        <Details>
            <![CDATA[
<p>The header "User-Agent" can be easily spoofed by the client. Adopting different behavior base on the User-Agent (for
crawler UA) is not recommended.</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSHUA">>Request Header "User-Agent"</BugCode>

    <!-- Cookie usage -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.CookieDetector">
        <Details>Identy direct cookie usage</Details>
    </Detector>

    <BugPattern type="COOKIE_USAGE">
        <ShortDescription>Cookie usage</ShortDescription>
        <LongDescription>Cookie value can be change by the client.</LongDescription>
        <Details>
            <![CDATA[
<p>The information store in the cookie should not be sensitive or related to the session. In most case, session
variables should be used. see HttpSession (HttpServletRequest.getSession())</p>
<p>Cookies can be use for information that need live longer than the session.</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECCU">Cookie usage</BugCode>

    <!-- Path traversal -->
    <Detector class="com.h3xstream.findsecbugs.PathTraversalDetector">
        <Details>Identify the different access to the filesystem that takes a path as parameter.</Details>
    </Detector>

    <BugPattern type="PATH_TRAVERSAL_IN">
        <ShortDescription>Potential Path traversal (read file)</ShortDescription>
        <LongDescription>An instance of {3} is created to read a file.</LongDescription>
        <Details>
            <![CDATA[
<p>A file is open to read its content. The path given is a <b>dynamic</b> parameter.</p>
<p>If unfiltered parameter is pass to this file API, content from an arbitrary path could be read.</p>
<p>This detector identify <b>potential</b> path transversal. In many case, the construct file path is not control
by the user. If it is the case, this bug instance can be ignored.</p>
<p>
<b>References</b><br/>
<a href="http://projects.webappsec.org/w/page/13246952/Path%20Traversal">WASC : Path Traversal</a><br/>
<a href="https://www.owasp.org/index.php/Path_Traversal">OWASP : Path Traversal</a><br/>
<a href="http://capec.mitre.org/data/definitions/126.html">CAPEC-126: Path Traversal</a><br/>
<a href="http://cwe.mitre.org/data/definitions/99.html">CWE-99: Improper Control of Resource Identifiers ('Resource Injection')</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECPTI">Path traversal to read file</BugCode>

    <BugPattern type="PATH_TRAVERSAL_OUT">
        <ShortDescription>Potential Path traversal (write file)</ShortDescription>
        <LongDescription>An instance of {3} is created to write a file.</LongDescription>
        <Details>
            <![CDATA[
<p>The class selected is use to open a file handle using a <b>dynamic</b> parameter.</p>
<p>If unfiltered input is pass to this function, content could be writen to an arbitrary path.</p>
<p>
<b>References</b><br/>
<a href="http://projects.webappsec.org/w/page/13246952/Path%20Traversal">WASC-33 : Path Traversal</a><br/>
<a href="https://www.owasp.org/index.php/Path_Traversal">OWASP : Path Traversal</a><br/>
<a href="http://capec.mitre.org/data/definitions/126.html">CAPEC-126: Path Traversal</a><br/>
<a href="http://cwe.mitre.org/data/definitions/99.html">CWE-99: Improper Control of Resource Identifiers ('Resource Injection')</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECPTO">Path traversal to write file</BugCode>


    <!-- Command injection -->
    <Detector class="com.h3xstream.findsecbugs.CommandInjectionDetector">
        <Details>Identify source of command injection</Details>
    </Detector>

    <BugPattern type="COMMAND_INJECTION">
        <ShortDescription>Command Injection</ShortDescription>
        <LongDescription>{3} is used to executed system command.</LongDescription>
        <Details>
            <![CDATA[
<p>The api highlight is used to executed system command. If unfiltered input is passed to this api, it can lead arbitrary command execution.</p>
<p>
<b>Reference</b><br/>
<a href="https://www.owasp.org/index.php/Command_Injection">OWASP : Command Injection</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECCI">Command Injection</BugCode>

    <!-- Weak FilenameUtils method -->
    <Detector class="com.h3xstream.findsecbugs.WeakFilenameUtilsMethodDetector">
        <Details>Identify the usage of some FilenameUtils methods</Details>
    </Detector>

    <BugPattern type="WEAK_FILENAMEUTILS">
        <ShortDescription>FilenameUtils partial filtering</ShortDescription>
        <LongDescription>FilenameUtils.{3} don't filter NULL byte.</LongDescription>
        <Details>
            <![CDATA[
<p>Some FilenameUtils' methods don't filter NULL byte (<code>0x00</code>).</p>
<p>The risk come from the removal of characters following the NULL byte.
This removal can occurs with many system API (ie. usage of the File object).</p>
<p>
<b>Reference</b><br/>
<a href="http://projects.webappsec.org/w/page/13246949/Null%20Byte%20Injection">WASC-28: Null Byte Injection</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECWF">FilenameUtils partial filtering</BugCode>


    <!-- Weak TrustManager -->
    <Detector class="com.h3xstream.findsecbugs.crypto.WeakTrustManagerDetector">
        <Details>Identify weak TrustManager implementation</Details>
    </Detector>

    <BugPattern type="WEAK_TRUST_MANAGER">
        <ShortDescription>Weak TrustManager implementation</ShortDescription>
        <LongDescription>The implementation of TrustManager is vulnerable to MITM attack.</LongDescription>
        <Details>
            <![CDATA[
<p>Empty TrustManager implementation are often used to connected easily to a host that is not signed by a root
<a href="http://en.wikipedia.org/wiki/Certificate_authority">certificate authority</a>. As a consequence, a
<a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">Man-in-the-middle attack</a>
can occurs since the client will be trusting any given certificate.
</p>

<p>
A TrustManager allowing specific certificates (based on a truststore for example) should be built.
Detail information for a proper implementation :
<a href="http://stackoverflow.com/a/6378872/89769">[1]</a> <a href="http://stackoverflow.com/a/5493452/89769">[2]</a>
</p>

<p>
<b>Reference</b><br/>
<a href="http://projects.webappsec.org/w/page/13246945/Insufficient%20Transport%20Layer%20Protection">WASC-04: Insufficient Transport Layer Protection</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECWTM">Identify weak TrustManager implementation</BugCode>

    <!-- JAXWS -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.JaxWsEndpointDetector">
        <Details>Identify web services endpoint that implements JAX-WS API</Details>
    </Detector>

    <BugPattern type="JAXWS_ENDPOINT">
        <ShortDescription>JAX-WS (JSR224) endpoint</ShortDescription>
        <LongDescription>{0}.{1} is SOAP Web Service endpoint</LongDescription>
        <Details>
            <![CDATA[
<p>This method is part of a SOAP Web Service.</p>
<p>
<b>Analysis needed</b>
<ul>
<li>The inputs should be track for potential vulnerabilities.</li>
<li>An authentication mechanism should be present.</li>
<li>The communication should ideally be over SSL.</li>
</ul>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECJWS">JAX-WS (JSR224) endpoint</BugCode>

    <!-- JAXRS -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.JaxRsEndpointDetector">
        <Details>Identify web services endpoint that implements JAX-RS API</Details>
    </Detector>

    <BugPattern type="JAXRS_ENDPOINT">
        <ShortDescription>JAX-RS (JSR311) endpoint</ShortDescription>
        <LongDescription>{0}.{1} is REST Web Service endpoint</LongDescription>
        <Details>
            <![CDATA[
<p>This method is part of a REST Web Service.</p>
<p>
<b>Analysis needed</b>
<ul>
<li>The inputs should be track for potential vulnerabilities.</li>
<li>An authentication mechanism should be present.</li>
<li>The communication should ideally be over SSL.</li>
<li>If the method allow include GET/POST, CSRF vulnerability should investigate.<sup>[1]</sup></li>
</ul>
</p>
<p>
1. <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)">OWASP - Cross-Site Request Forgery</a>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECJRS">JAX-RS (JSR311) endpoint</BugCode>

    <!-- Tapestry -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.TapestryEndpointDetector">
        <Details>Identify Tapestry "Pages" that serve as input</Details>
    </Detector>

    <BugPattern type="TAPESTRY_ENDPOINT">
        <ShortDescription>Tapestry Page</ShortDescription>
        <LongDescription>{0} is a Tapestry Page</LongDescription>
        <Details>
            <![CDATA[
<p>Tapestry endpoint are discover at the application startup and are requires to be in <code>[base.package.name].pages</code>.
When a request is received, the GET/POST parameters are mapped to field. The mapping is either done with fieldName:</p>
<pre><code>
    [...]
    protected String input;
    [...]
</code></pre>
<p>or
the definition of an explicit annotation:
</p>
<pre><code>
    [...]
    @org.apache.tapestry5.annotations.Parameter
    protected String parameter1;

    @org.apache.tapestry5.annotations.Component(id = "password")
    private PasswordField passwordField;
    [...]
</code></pre>
<p>The page is mapped to the view <code>[/package/PageName].tml.</code></p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECTE">Tapestry Page</BugCode>


    <!-- Wicket -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.WicketEndpointDetector">
        <Details>Identify Wicket "WebPages" that serve as input</Details>
    </Detector>

    <BugPattern type="WICKET_ENDPOINT">
        <ShortDescription>Wicket WebPage</ShortDescription>
        <LongDescription>{0} is a Wicket WebPage</LongDescription>
        <Details>
            <![CDATA[
<p>This class represent a Wicket WebPage.</p>
<p>The input are read from a PageParameters instance passed to the constructor.</p>
<p>The current page is mapped to the view [/package/WebPageName].html.</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECWE">Wicket WebPage</BugCode>

    <!-- Weak Message Digest -->
    <Detector class="com.h3xstream.findsecbugs.crypto.WeakMessageDigestDetector">
        <Details>Identify the use of weak MessageDigest that could be replace recommended standards.</Details>
    </Detector>

    <BugPattern type="WEAK_MESSAGE_DIGEST">
        <ShortDescription>Weak MessageDigest</ShortDescription>
        <LongDescription>{3} is not a recommended MessageDigest</LongDescription>
        <Details>
            <![CDATA[
<p>The algorithm used is not a recommended MessageDigest.</p>
<p>The <a href="http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html">NIST</a> recommended to use either SHA-1, SHA-224*, SHA-256, SHA-384 or SHA-512.</p>
<p><small>* SHA-224 algorithm is not provided by <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html#SUNProvider"> SUN provider.</a></small></p>
<p>
<b>Reference</b><br/>
<a href="http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html">NIST Approved Algorithms</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECWMD">Weak MessageDigest</BugCode>

    <!-- Custom Message Digest -->
    <Detector class="com.h3xstream.findsecbugs.crypto.CustomMessageDigestDetector">
        <Details>Identify the implementation of custom MessageDigest</Details>
    </Detector>

    <BugPattern type="CUSTOM_MESSAGE_DIGEST">
        <ShortDescription>Custom MessageDigest</ShortDescription>
        <LongDescription>{0} is a custom MessageDigest</LongDescription>
        <Details>
            <![CDATA[
<p>Implementing custom MessageDigest is error-prone.</p>
<p>The <a href="http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html">NIST</a> recommended to use either SHA-1, SHA-224*, SHA-256, SHA-384 or SHA-512.</p>
<p><small>* SHA-224 algorithm is not provided by <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html#SUNProvider"> SUN provider.</a></small></p>

<p>
    <b>Vulnerable code:</b><br/>
<pre>MyProprietaryMessageDigest extends MessageDigest {
    @Override
    protected byte[] engineDigest() {
        [...]
        //Creativity is a bad idea
        return [...];
    }
}</pre>
</p>
<p>
    <b>Solution:</b><br/>
<pre>MessageDigest sha256Digest = MessageDigest.getInstance("SHA256");
sha256Digest.update(password.getBytes());</pre>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECCMD">Custom MessageDigest</BugCode>

    <!-- FileUpload Filename -->
    <Detector class="com.h3xstream.findsecbugs.FileUploadFilenameDetector">
        <Details>The filename given by FileUpload api can be tampered by the client.</Details>
    </Detector>

    <BugPattern type="FILE_UPLOAD_FILENAME">
        <ShortDescription>Tainted filename read</ShortDescription>
        <LongDescription>The filename read can be tampered by the client</LongDescription>
        <Details>
            <![CDATA[
<p>The filename given by FileUpload api can be tampered by the client.</p>
<p>It can take value such as:</p>
<ul>
<li><code>"../../../config/overide_file"</code></li>
<li><code>"shell.jsp\u0000expected.gif"</code></li>
</ul>
<p>Therefore it should not be passed directly to filesystem api. If acceptable, a new filename should be picked.
Otherwise, the original filename should be properly escaped.</p>
<p>
<b>Reference</b><br/>
<a href="http://blogs.securiteam.com/index.php/archives/1268">Securiteam: File upload security recommendations</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECFUN">Tainted filename read</BugCode>

    <!-- ReDOS -->

    <Detector class="com.h3xstream.findsecbugs.ReDosDetector">
        <Details>The regular expression can grow exponentially with some input.</Details>
    </Detector>

    <BugPattern type="REDOS">
        <ShortDescription>ReDOS</ShortDescription>
        <LongDescription>The regular expression "{0}" is vulnerable to ReDOS</LongDescription>
        <Details>
            <![CDATA[

<p>
    ReDOS stands for Regular expression Denial of Service. The regular expression (RegEx) identify may take a large amount of time
    when analysing certain strings.
<p>
    For example the following RegEx, the input "<code>aaaaaaaaaaaaaaaaX</code>" will cause the RegEx engine to analyse 65536 different paths.<sup>[1] Example taken from OWASP reference</sup>
    <pre>^(a+)+$</pre>
</p>
<p>
    Therefore, it is possible that a single request cause a large amount of computation on the server side.
</p>

<p>
<b>References</b><br/>
<a href="http://www.jroller.com/sebastianKuebeck/entry/detecting_and_preventing_redos_vulnerabilities">Sebastian Kubeck's Weblog: Detecting and Preventing ReDoS Vulnerabilities</a><br/>
<sup>[1]</sup> <a href="https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS">OWASP : Regular expression Denial of Service</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECRD">ReDOS</BugCode>


    <!-- SAXParser XXE -->
    <Detector class="com.h3xstream.findsecbugs.xxe.SaxParserXxeDetector">
        <Details>Identify SAXParser usage vulnerable to XXE</Details>
    </Detector>

    <BugPattern type="XXE">
        <ShortDescription>XML parsing vulnerable to XXE attacks</ShortDescription>
        <LongDescription>The usage of {3} is vulnerable to Xml External Entity attacks</LongDescription>
        <Details>
            <![CDATA[
<p>Xml External Entity attacks can occurs when the XML parsers support XML entities and received
user input as XML content.</p>
<b>Risk 1: Expose local file content (XXE : <u>X</u>ml e<u>X</u>ternal <u>E</u>ntity)</b>
<p>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
   &lt;!ELEMENT foo ANY &gt;
   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;
</pre>
</p>
<b>Risk 2: Denial of service (XEE : <u>X</u>ml <u>E</u>ntity <u>E</u>xpansion)</b>
<p>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE s [
&lt;!ENTITY x &quot;OVERLONG_CONTENT_HERE_WITH_MORE_THAN_10^5_CHARACTERS&quot;&gt;
]&gt;
&lt;foo&gt;
    &amp;x;
    &amp;x;
    [...]
&lt;/foo&gt;
</pre>
</p>
<p>
<b>References</b><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/Testing_for_XML_Injection_(OWASP-DV-008)">OWASP : Testing for XML Injection</a><br/>
<a href="http://clawslab.nds.rub.de/wiki/index.php/XML_Generic_Entity_Expansion">WS-Attacks.org: XML Generic Entity Expansion</a><br/>
<a href="http://clawslab.nds.rub.de/wiki/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXXE">XML parsing vulnerable to XXE attacks</BugCode>

    <!-- XPath Injection for Javax -->
    <Detector class="com.h3xstream.findsecbugs.xpath.XPathInjectionJavaxDetector">
        <Details>Find XPath query that use tainted input (javax.xml api)</Details>
    </Detector>

    <Detector class="com.h3xstream.findsecbugs.xpath.XPathInjectionApacheXPathApiDetector">
        <Details>Find XPath query that use tainted input (org.apache.xpath api)</Details>
    </Detector>

    <BugPattern type="XPATH_INJECTION">
        <ShortDescription>Potential XPath Injection</ShortDescription>
        <LongDescription>The use of {3} is vulnerable to XPath injection</LongDescription>
        <Details>
            <![CDATA[
<p>
XPath injection risks are simlar to SQL injection. If the XPath query contain unfilter user input, the complete datasource
could be expose.
</p>
<p>
<b>References</b><br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-39: XPath Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/643.html">CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61407250">CERT: IDS09-J. Prevent XPath Injection (archive)</a><br/>
<a href="http://media.blackhat.com/bh-eu-12/Siddharth/bh-eu-12-Siddharth-Xpath-WP.pdf">Black Hat Europe 2012: Hacking XPath 2.0</a><br/>
<a href="http://www.balisage.net/Proceedings/vol7/html/Vlist02/BalisageVol7-Vlist02.html">Balisage: XQuery Injection</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXPI">XPath Injection</BugCode>

    <!-- Struts1 -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.Struts1EndpointDetector">
        <Details>Identify Struts 1 endpoint (also called Action)</Details>
    </Detector>

    <BugPattern type="STRUTS1_ENDPOINT">
        <ShortDescription>Struts 1 Action</ShortDescription>
        <LongDescription>{0} is a Struts 1 endpoint</LongDescription>
        <Details>
            <![CDATA[
<p>This class is a Struts Action.</p>
<p>Once a request is route to this controller, a Form object will be builded that constains
the HTTP parameters.</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSTR1">Struts 1 Action</BugCode>

    <!-- Struts2 -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.Struts2EndpointDetector">
        <Details>Identify Struts 2 endpoint</Details>
    </Detector>
    <BugPattern type="STRUTS2_ENDPOINT">
        <ShortDescription>Struts 2 endpoint</ShortDescription>
        <LongDescription>{0} is a Struts 2 endpoint</LongDescription>
        <Details>
            <![CDATA[
<p>In struts 2, the endpoint are Plain Old Java Object (POJO) which means no Interface/Class are implements/extends.</p>
<p>When a request is route to its controller (like the selected class). The different HTTP parameters are mapped to setter of
the class. Therefor all setter of this class should be consider as input even if the form expected to be used doesn't include
all of them.</p>

]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSTR2">Struts 2 endpoint</BugCode>

    <!-- Spring Controller -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.SpringMvcEndpointDetector">
        <Details>Identify Spring Controller (also called Controller)</Details>
    </Detector>
    <BugPattern type="SPRING_ENDPOINT">
        <ShortDescription>Spring endpoint</ShortDescription>
        <LongDescription>{0} is a Spring controller</LongDescription>
        <Details>
            <![CDATA[
<p>This class is a Spring Controller. All method annotated with <code>RequestMapping</code> are reachable remotely.</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSC">Spring Controller</BugCode>

    <!-- Sql Injection -->
    <Detector class="com.h3xstream.findsecbugs.injection.sql.SqlInjectionDetector">
        <Details>Identify various kind of SQL Injection in API that accepts strings.</Details>
    </Detector>

    <BugPattern type="SQL_INJECTION">
        <ShortDescription>Potential SQL Injection</ShortDescription>
        <LongDescription>The query is potentially vulnerable SQL injection</LongDescription>
        <Details>
            <![CDATA[
<p>
The input values associated to the SQL queries should be escape properly. Prepare statement can be use to easily mitigate the risk
(Available for all major API : JDO, JPA and Hibernate). Alternatively, typed API such as Hibernate Criteria and Querydsl
can be used.
</p>
<p>
    <b>Vulnerable code samples:</b><br/>
    <pre>Session session = sessionFactory.openSession();
Query q = session.createQuery("select t from UserEntity t where id = " + input);
q.execute();</pre>
</p>
<p>
<b>References</b><br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSQLI">SQL Injection</BugCode>

    <!-- LDAP Injection -->
    <Detector class="com.h3xstream.findsecbugs.injection.ldap.LdapInjectionDetector">
        <Details>Identify various kind of LDAP Injection in JNDI and UnboundId API.</Details>
    </Detector>

    <BugPattern type="LDAP_INJECTION">
        <ShortDescription>Potential LDAP Injection</ShortDescription>
        <LongDescription>The query could be vulnerable LDAP injection</LongDescription>
        <Details>
            <![CDATA[
<p>
Just like SQL query, all inputs place inside LDAP query should be escape properly.
</p>
<p>
    <b>Code at risk:</b><br/>
    <pre>NamingEnumeration<SearchResult> answers = context.search("dc=People,dc=example,dc=com",
        "(uid=" + username + ")", ctrls);</pre>
</p>
<p>
<b>References</b><br/>
<a href="http://projects.webappsec.org/w/page/13246947/LDAP%20Injection">WASC-29: LDAP Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/90.html">CWE-90: Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</a><br/>
<a href="http://www.veracode.com/security/ldap-injection">LDAP Injection Guide: Learn How to Detect LDAP Injections and Improve LDAP Security</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECLDAPI">LDAP Injection</BugCode>


    <!-- Script Engine Code injection -->
    <Detector class="com.h3xstream.findsecbugs.injection.script.ScriptEngineInjectionDetector">
        <Details>Identify various kind of code injection.</Details>
    </Detector>

    <BugPattern type="SCRIPT_ENGINE_INJECTION">
        <ShortDescription>Potential code injection when using Script Engine</ShortDescription>
        <LongDescription>This code evaluation could be vulnerable code injection</LongDescription>
        <Details>
            <![CDATA[
<p>
    Dymanic code is being evaluate. A concious analysis of the code construction should be made. Malicious code execution
    could lead to data leakage or operating system compromised.
</p>
<p>
    If the evaluation of user code is intended, a proper sandboxing should be applied (see references).
</p>
<p>
<b>References</b><br/>
<a href="http://codeutopia.net/blog/2009/01/02/sandboxing-rhino-in-java/">CodeUtopia.net: Sandboxing Rhino in Java</a><br/>
<a href="https://github.com/cloudbees/rhino-sandbox">Cloudbees Rhino Sandbox</a>: Utility to secure Rhino<br/>
<a href="http://calumleslie.blogspot.ca/2008/06/simple-jvm-sandboxing.html">Simple JVM sandboxing</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SCRIPTE">Script Engine Injection</BugCode>

    <!-- Bad Hexa -->
    <Detector class="com.h3xstream.findsecbugs.crypto.BadHexadecimalConversionDetector">
        <Details>Identify Bad hexadecimal concatenation</Details>
    </Detector>
    <BugPattern type="BAD_HEXA_CONVERSION">
        <ShortDescription>Bad hexadecimal concatenation</ShortDescription>
        <LongDescription>Identify bad hexadecimal concatenation</LongDescription>
        <Details>
            <![CDATA[
<p>When converting a byte array to a string, a conversion mistake can be made if the array is read byte by byte.
The following sample illustrate the use of Integer.toHexString() which will trim the trailling "0".
<pre>
MessageDigest md = MessageDigest.getInstance("SHA-1");
byte[] resultBytes = md.digest(password.getBytes("UTF-8"));

StringBuilder stringBuilder = new StringBuilder();
for(byte b :resultBytes) {
    stringBuilder.append( Integer.toHexString( b & 0xFF ) );
}

return stringBuilder.toString();
</pre>
</p>

<p>
This mistake can weaken the hashing function use since more collisions are introduce.<br/>
The values "0x0679" "0x6709" would become "679".
</p>

<p>
In this situation, the use of toHexString() should be replace by a String.format() as follow.
<pre>
stringBuilder.append( String.format( "%02X", b ) );
</pre>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECBHC">Bad hexadecimal concatenation</BugCode>

    <!-- Hazelcast Symmetric encryption -->
    <Detector class="com.h3xstream.findsecbugs.crypto.HazelcastSymmetricEncryptionDetector">
        <Details>Hazelcast Symmetric encryption</Details>
    </Detector>
    <BugPattern type="HAZELCAST_SYMMETRIC_ENCRYPTION">
        <ShortDescription>Hazelcast Symmetric encryption</ShortDescription>
        <LongDescription>The network communication for Hazelcast are configure to symmetric cipher</LongDescription>
        <Details>
            <![CDATA[
<p>The network communication for Hazelcast is configure to a symmetric cipher (probably DES or blowfish).</p>
<p>Those ciphers alone do not provide integrity or secure authentication.</a>.
The use of asymmetric encryption should be preferred.</p>
<p>
<b>Reference</b><br/>
<a href="http://projects.webappsec.org/w/page/13246945/Insufficient%20Transport%20Layer%20Protection">WASC-04 : Insufficient Transport Layer Protection</a><br/>
<a href="http://www.hazelcast.com/documentation.jsp#Encryption">Hazelcast Documentation : Encryption (see second part)</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECHAZ">Hazelcast Symmetric encryption</BugCode>

    <!-- NullCipher's use -->
    <Detector class="com.h3xstream.findsecbugs.crypto.NullCipherDetector">
        <Details>Identify the use of NullCipher</Details>
    </Detector>
    <BugPattern type="NULL_CIPHER">
        <ShortDescription>The use of NullCipher might be unwanted</ShortDescription>
        <LongDescription>The use of NullCipher might be unwanted</LongDescription>
        <Details>
            <![CDATA[
<p>
The NullCipher is rarelly use. It implement the Cipher interface by returning a ciphertext identical to the plaintext.
In few context including testing, NullCipher can be appropriate.
</p>

<p>
    <b>Vulnerable code:</b><br/>
<pre>Cipher doNothingCihper = new NullCipher();
[...]
//The ciphertext produces will be identical to the plaintext.
byte[] cipherText = c.doFinal(plainText);</pre>

</p>
<p>
    <b>Solution</b><br/>
    Avoid using the NullCipher. Its accidental use can cause important confidentiality risk.
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECNC">Bad hexadecimal concatenation</BugCode>

    <!-- Unencrypted Socket encryption -->
    <Detector class="com.h3xstream.findsecbugs.crypto.UnencryptedSocketDetector">
        <Details>Unencrypted socket</Details>
    </Detector>
    <BugPattern type="UNENCRYPTED_SOCKET">
        <ShortDescription>Unencrypted socket</ShortDescription>
        <LongDescription>Unencrypted socket to {0} (instead of SSLSocket)</LongDescription>
        <Details>
            <![CDATA[
<p>
The communication started will not be encrypted. The traffic could be red by an attacker intercepting the communication.
</p>
<p>
<b>Vulnerable code:</b><br/>
Plain socket (Clear text communication):
<pre>Socket soc = new Socket("www.google.com",80);</pre>
</p>
<p>
<b>Solution:</b><br/>
SSL Socket (Secure communication):
<pre>Socket soc = SSLSocketFactory.getDefault().createSocket("www.google.com", 443);</pre>
</p>

<p>
<b>Reference</b><br/>
<a href="https://www.owasp.org/index.php/Top_10_2010-A9">OWASP : Insufficient Transport Layer Protection</a><br/>
<a href="http://projects.webappsec.org/w/page/13246945/Insufficient%20Transport%20Layer%20Protection">WASC-04 : Insufficient Transport Layer Protection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/311.html">CWE-311: Missing Encryption of Sensitive Data</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECUS">Unencrypted socket</BugCode>


    <!-- DES usage -->
    <Detector class="com.h3xstream.findsecbugs.crypto.DesUsageDetector">
        <Details>DES / DESede should be replace by AES</Details>
    </Detector>
    <BugPattern type="DES_USAGE">
        <ShortDescription>DES / DESede usage</ShortDescription>
        <LongDescription>DES / DESede should be replace by AES</LongDescription>
        <Details>
            <![CDATA[
<p>
DES and DESede (3DES), previously recommended, are not consider strong ciphers for modern applications. DESede should
only be use because of hardware limitation. Currently, the NIST recommend the usage of AES block cipher.
</p>
<p>
    <b>Weak code:</b>
<pre>Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>

</p>
<p>
    <b>Solution:</b>
    <pre>Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<p>
<b>References</b><br/>
<a href="http://www.nist.gov/itl/fips/060205_des.cfm">NIST Withdraws Outdated Data Encryption Standard</a><br/>
<a href="http://cwe.mitre.org/data/definitions/327.html">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECDU">DES / DESede usage</BugCode>

    <!-- RSA NoPadding -->
    <Detector class="com.h3xstream.findsecbugs.crypto.RsaNoPaddingDetector">
        <Details>RSA cipher without proper padding</Details>
    </Detector>
    <BugPattern type="RSA_NO_PADDING">
        <ShortDescription>RSA NoPadding</ShortDescription>
        <LongDescription>RSA cipher without proper padding</LongDescription>
        <Details>
            <![CDATA[
<p>
The software uses the RSA algorithm but does not incorporate Optimal Asymmetric Encryption Padding (OAEP), which might weaken the encryption.
</p>
<p>
<b>Vulnerable code:</b><br/>
<pre>Cipher.getInstance("RSA/NONE/NoPadding")</pre>
</p>
<p>
<b>Solution:</b><br/>
The code should be replace by:<br/>
<pre>Cipher.getInstance("RSA/ECB/OAEPWithMD5AndMGF1Padding")</pre>
</p>
<p>
<b>Reference</b><br/>
<a href="http://cwe.mitre.org/data/definitions/780.html">CWE-780: Use of RSA Algorithm without OAEP</a><br/>
<a href="http://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/">Root Labs: Why RSA encryption padding is critical</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECRNP">RSA NoPadding</BugCode>

    <!-- Hard code password -->
    <Detector class="com.h3xstream.findsecbugs.password.GoogleApiKeyDetector">
        <Details>Identify hardcode Google API key</Details>
    </Detector>

    <!-- Identify JNDI credentials -->
    <Detector class="com.h3xstream.findsecbugs.password.JndiCredentialsDetector">
        <Details>Identify hardcoded credentials in context initialization</Details>
    </Detector>

    <BugPattern type="HARD_CODE_PASSWORD">
        <ShortDescription>Hard code password</ShortDescription>
        <LongDescription>Hard code password</LongDescription>
        <Details>
            <![CDATA[
<p>
Password should not be kept in the source code. The source code are widely share in the entreprise environement.
Passwords and secret keys can be managed more easily when being separated in configuration files or keystores.
</p>
<p><b>Vulnerable code examples:</b><br/>
<br/>
<pre>private String SECRET_PASSWORD = "letMeIn!";</pre>
<br/>
<pre>Properties props = new Properties();
props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");</pre>
</p>

<p>
<b>References</b><br/>
<a href="http://cwe.mitre.org/data/definitions/321.html">CWE-321: Use of Hard-coded Cryptographic Key</a><br/>
<a href="http://cwe.mitre.org/data/definitions/259.html">CWE-259: Use of Hard-coded Password</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECHCP">Hard code password</BugCode>


    <!-- Struts Form Validation -->
    <Detector class="com.h3xstream.findsecbugs.StrutsValidatorFormDetector">
        <Details>Identify Struts Form with no input validation</Details>
    </Detector>
    <BugPattern type="STRUTS_FORM_VALIDATION">
        <ShortDescription>Struts Form with no input validation</ShortDescription>
        <LongDescription>Struts Form with no input validation</LongDescription>
        <Details>
            <![CDATA[
<p>
Form inputs should have minimal input validation. Preventive validation can possibly mitigate unknown risk.
</p>
<p>
Validation can be introduce by implementing a <code>validate</code> method.
<pre>
public class RegistrationForm extends ValidatorForm {

    private String name;
    private String email;

    [...]

    public ActionErrors validate(ActionMapping mapping, HttpServletRequest request) {
        //Validation code goes here.
    }
}
</pre>
</p>
<p>
<b>Reference</b><br/>
<a href="http://cwe.mitre.org/data/definitions/106.html">CWE-106: Struts: Plug-in Framework not in Use</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSFV">Struts Form with no input validation</BugCode>

    <!-- XSS Filter -->
    <Detector class="com.h3xstream.findsecbugs.xss.XSSRequestWrapperDetector">
        <Details>Identify XSSRequestWrapper (weak XSS protection)</Details>
    </Detector>
    <BugPattern type="XSS_REQUEST_WRAPPER">
        <ShortDescription>XSSRequestWrapper is a weak XSS protection</ShortDescription>
        <LongDescription>XSSRequestWrapper is a weak XSS protection</LongDescription>
        <Details>
            <![CDATA[
<p>
A implementation of <code>HttpServletRequestWrapper</code> called <code>XSSRequestWrapper</code> was publish through
various blog sites. <sup><a href="http://java.dzone.com/articles/stronger-anti-cross-site">[1]</a></sup>
<sup><a href="http://www.javacodegeeks.com/2012/07/anti-cross-site-scripting-xss-filter.html">[2]</a></sup>
</p>
<p>
The filtering is weak for few reasons:
<ul>
<li>It covers only parameters not headers and side-channel inputs</li>
<li>The replace chain can be bypass easly (see example below)</li>
<li>It's a black list of very specific patterns</li>
</ul>
</p>
<p>
<b>Example of bypass</b><br/>
</p>
<pre>&lt;scrivbscript:pt&gt;alert(1)&lt;/scrivbscript:pt&gt;</pre>
<p>
The previous input will be transform to <b><code>"&lt;script&gt;alert(1)&lt;/script&gt;"</code></b>.

The removal of <code>"vbscript:"</code> is after the replacement of <code>"&lt;script&gt;.*&lt;/script&gt;"</code>.
</p>
<p>
For an indepth protection, choose solution that filter characters automatically in the <b><u>view</u></b> (template, jsp, ...).
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXRW">Hard code password</BugCode>


    <!-- Blowfish key size -->
    <Detector class="com.h3xstream.findsecbugs.crypto.InsufficientKeySizeBlowfishDetector">
        <Details>Identify Blowfish usage with weak key size</Details>
    </Detector>
    <BugPattern type="BLOWFISH_KEY_SIZE">
        <ShortDescription>Blowfish usage with weak key size</ShortDescription>
        <LongDescription>Blowfish usage with weak key size</LongDescription>
        <Details>
            <![CDATA[
<p>
The Blowfish cipher supported keysize from 32 bits to 448 bits.
Small key size make the the ciphertext vulnerable to brute force attack.
At least 128 bits entropy should be used when generating the key.
</p>
<p>
Unless the code is a legacy implementation that need maintenance, AES block cipher should be use instead.
</p>

<p><b>Vulnerable code:</b><br/>
<pre>KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
keyGen.init(64);</pre>
</p>

<p><b>Solution:</b><br/>
<pre>KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
keyGen.init(128);</pre>
</p>

<p>
<b>Reference</b><br/>
<a href="http://en.wikipedia.org/wiki/Blowfish_(cipher)">Blowfish_(cipher)</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECBKS">Blowfish usage with weak key size</BugCode>


    <!-- RSA key size -->
    <Detector class="com.h3xstream.findsecbugs.crypto.InsufficientKeySizeRsaDetector">
        <Details>Identify RSA usage with weak key size</Details>
    </Detector>
    <BugPattern type="RSA_KEY_SIZE">
        <ShortDescription>RSA usage with weak key size</ShortDescription>
        <LongDescription>RSA usage with weak key size</LongDescription>
        <Details>
            <![CDATA[
<p>"RSA Laboratories currently recommends key sizes of 1024 bits for corporate use and 2048 bits for extremely valuable keys like the root key pair used by a certifying authority". <sup>[1]</sup></p>

<p><b>Vulnerable code:</b><br/>
<pre>
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(512);
</pre>
</p>

<p><b>Solution:</b><br/>
The KeyPairGenerator creation should be as follow with at least 2048 bit key size.<br/>
<pre>
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(2048);
</pre>
</p>
<p>
<b>References</b><br/>
[1] <a href="http://www.rsa.com/rsalabs/node.asp?id=2218">RSA Laboratories : 3.1.5 How large a key should be used in the RSA cryptosystem?</a><br/>
<a href="http://en.wikipedia.org/wiki/Key_size#Asymmetric%5Falgorithm%5Fkey%5Flengths">Wikipedia : Asymmetric algorithm key lengths</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECRKS">RSA usage with weak key size</BugCode>

    <!-- Unvalidated redirect -->
    <Detector class="com.h3xstream.findsecbugs.injection.redirect.UnvalidatedRedirectDetector">
        <Details>Identify redirect with user input URL</Details>
    </Detector>
    <BugPattern type="UNVALIDATED_REDIRECT">
        <ShortDescription>Unvalidated Redirect</ShortDescription>
        <LongDescription>Unvalidated Redirect</LongDescription>
        <Details>
            <![CDATA[
<p>
    Unvalidated request is a vulnerability that facilitate fishing attack.
</p>
<p>
    <b>Scenario</b><br/>
    1. A user is requested to visit the malicious url : http://website.com/login?redirect=http://evil.vvebsite.com/fake/login<br/>
    2. The user is redirect to a fake login. (http://evil.vvebsite.com/fake/login)<br/>
    3. The user enter his credentials.<br/>
    4. He is redirect to the original website.<br/>
    <br/>
    This is attack is plausible because most users don't double check the url after the redirection. Also, redirection to
    authenticate are very common.
</p>
<p>
    <b>Vulnerable code:</b></br/>
    <pre>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    [...]
    resp.sendRedirect(req.getParameter("redirectUrl"));
    [...]
}</pre>
</p>
<p>
    <b>Solution/Counter measures</b><br/>
    <ul>
        <li>Accept only relative path</li>
        <li>White list URLs (if possible)</li>
        <li>Validate that the beginning of the URL is part of white list</li>
    </ul>
</p>
<p>
    <b>References</b><br/>
    <a href="http://projects.webappsec.org/w/page/13246981/URL%20Redirector%20Abuse">WASC-38 : URL Redirector Abuse</a><br/>
    <a href="https://www.owasp.org/index.php/Top_10_2010-A10-Unvalidated_Redirects_and_Forwards">OWASP Top 10 A10: Unvalidated Redirects and Forwards</a>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECUR">Unvalidated Redirect</BugCode>


    <!-- XSS in JSP -->
    <Detector class="com.h3xstream.findsecbugs.jsp.JspXssDetector">
        <Details>Identify tainted inputs print in JSP views.</Details>
    </Detector>
    <BugPattern type="XSS_JSP_PRINT">
        <ShortDescription>Potential XSS in JSP</ShortDescription>
        <LongDescription>Potential XSS in JSP</LongDescription>
        <Details>
            <![CDATA[
<p>
    A potential XSS was found. It could be use to execute unwanted Javascript on client browser. (See references)
</p>
<p>
    <b>Vulnerable code:</b>
    <pre><%
String taintedInput = (String) request.getAttribute("input");
%>
[...]
<%= taintedInput %></pre>
</p>
<p>
    <b>Proper code:</b>
    <pre>
<%
String taintedInput = (String) request.getAttribute("input");
%>
[...]
<%= ESAPI.encoder().encodeForHTML(taintedInput) %>
    </pre>
</p>
<p>
    <b>References</b><br/>
<a href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8 : Cross Site Scripting</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2010-A2-Cross-Site_Scripting_(XSS)">OWASP Top 10 A2 :Cross-Site Scripting (XSS)</a><br/>
<a href="http://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXSS1">Potential XSS in JSP</BugCode>

    <!-- XSS in servlet -->
    <BugPattern type="XSS_SERVLET">
        <ShortDescription>Potential XSS in servlet</ShortDescription>
        <LongDescription>Potential XSS in servlet</LongDescription>
        <Details>
            <![CDATA[
<p>
    A potential XSS was found. It could be use to execute unwanted Javascript on client browser. (See references)
</p>
<p>
    <b>Vulnerable code:</b>
<pre>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String input1 = req.getParameter("input1");
    [...]
    resp.getWriter().write(input1);
}</pre>
</p>
<p>
    <b>Proper code:</b>
<pre>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String input1 = req.getParameter("input1");
    [...]
    resp.getWriter().write(ESAPI.encoder().encodeForHTML(input1));
}</pre>
</p>
<p>
    <b>References</b><br/>
<a href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8 : Cross Site Scripting</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2010-A2-Cross-Site_Scripting_(XSS)">OWASP Top 10 A2 :Cross-Site Scripting (XSS)</a><br/>
<a href="http://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXSS2">Potential XSS in servlet</BugCode>

    <!-- XML decoder -->
    <Detector class="com.h3xstream.findsecbugs.XmlDecoderDetector">
        <Details>Identify usage for XMLDecoder (a dangerous XML serializer).</Details>
    </Detector>
    <BugPattern type="XML_DECODER">
        <ShortDescription>XMLDecoder usage</ShortDescription>
        <LongDescription>XMLDecoder usage</LongDescription>
        <Details>
            <![CDATA[
<p>
    XMLDecoder should not be use to parse user data. Deserializing user input can lead to arbitrary code execution.
    It is possible because XMLDecoder support method invocation. It is intended to call to call setter method.
    In practice, any method can be called.
</p>
<p>
    <b>Malicious XML example:</b>
</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;java version="1.4.0" class="java.beans.XMLDecoder"&gt;
  &lt;object class="java.io.PrintWriter"&gt;
    &lt;string>/tmp/Hacked.txt&lt;/string&gt;
    &lt;void method="println"&gt;
      &lt;string>Hello World!&lt;/string&gt;
    &lt;/void&gt;
    &lt;void method="close"/&gt;
  &lt;/object&gt;
&lt;/java&gt;
</pre>
<p>
The previous XML code will cause the creation of a file with the content "Hello World!".
</p>
<p>
    <b>Vulnerable code:</b></br/>
    <pre>XMLDecoder d = new XMLDecoder(in);
try {
    Object result = d.readObject();
}
[...]</pre>
</p>
<p>
<b>Solution:</b></br/>
The solution is to avoid using XML decoder to parse content from untrusted source.
</p>

<p>
<b>References</b><br/>
<a href="http://blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html">Dinis Cruz Blog: Using XMLDecoder to execute server-side Java Code on an Restlet application</a><br/>
<a href="https://securityblog.redhat.com/2014/01/23/java-deserialization-flaws-part-2-xml-deserialization/">RedHat blog : Java deserialization flaws: Part 2, XML deserialization</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="XMLDEC">XMLDecoder usage</BugCode>

    <!-- Static IV -->
    <Detector class="com.h3xstream.findsecbugs.crypto.StaticIvDetector">
        <Details>Identity initialization vector (IV) that are not properly generated.</Details>
    </Detector>
    <BugPattern type="STATIC_IV">
        <ShortDescription>Static IV</ShortDescription>
        <LongDescription>The initialization vector (IV) is not properly generated</LongDescription>
        <Details>
            <p>
                Initialization vector must be regenerated for each message encrypted.
            </p>
            <p>
                <b>References</b><br/>
                <a href="http://en.wikipedia.org/wiki/Initialization_vector">Wikipedia: Initialization vector</a><br/>
                <a href="http://cwe.mitre.org/data/definitions/329.html">CWE-329: Not Using a Random IV with CBC Mode</a><br/>
                <a href="https://defuse.ca/cbcmodeiv.htm">Encryption - CBC Mode IV: Secret or Not?</a><br/>
            </p>
        </Details>
    </BugPattern>
    <BugCode abbrev="STAIV">Static IV</BugCode>

    <!-- Ciphers with no integrity -->
    <Detector class="com.h3xstream.findsecbugs.crypto.CipherWithNoIntegrityDetector">
        <Details>Identity ciphers that does not provide integrity.</Details>
    </Detector>

    <!-- ECB Mode -->

    <BugPattern type="ECB_MODE">
        <ShortDescription>ECB mode used</ShortDescription>
        <LongDescription>The cipher chosen use ECB mode</LongDescription>
        <Details>
            <![CDATA[
<p>An authenticated cipher mode should be used instead of ECB mode.</p>
<p>
<b>Code at risk:</b>
    <pre>Cipher c = Cipher.getInstance("AES/ECB/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<p>
    <b>Solution:</b>
    <pre>Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
</p>

<p>
<b>References</b><br/>
<a href="http://en.wikipedia.org/wiki/Authenticated_encryption">Wikipedia: Authenticated encryption</a><br/>
<a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01">NIST: Authenticated Encryption Modes</a><br/>
<a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29">Wikipedia: Block cipher modes of operation</a><br/>
<a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">NIST: Recommendation for Block Cipher Modes of Operation</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECECB">Bad hexadecimal concatenation</BugCode>

    <!-- Padding oracle -->
    <BugPattern type="PADDING_ORACLE">
        <ShortDescription>Cipher is susceptible to padding oracle</ShortDescription>
        <LongDescription>The cipher is susceptible to padding oracle</LongDescription>
        <Details>
<![CDATA[
<p>
    This specific mode of CBC with PKCS5Padding is susceptible to padding oracle. An adversary could potentially decrypt the
    message if the system exposed the difference between an plaintext with invalid padding or valid padding.
</p>
<p>
    <b>Code at risk:</b>
    <pre>Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<p>
    <b>Solution:</b>
    <pre>Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<p>
    <b>References</b><br/>
    <a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf">Padding Oracles for the masses (by Matias Soler)</a>
    <a href="http://en.wikipedia.org/wiki/Authenticated_encryption">Wikipedia: Authenticated encryption</a><br/>
    <a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01">NIST: Authenticated Encryption Modes</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="PADORA">Cipher is susceptible to padding oracle</BugCode>

    <!-- Integrity missing -->
    <BugPattern type="CIPHER_INTEGRITY">
        <ShortDescription>Cipher with no integrity</ShortDescription>
        <LongDescription>The cipher used does not provide integrity</LongDescription>
        <Details>
<![CDATA[
<p>
    The ciphertext produced are susceptible to be alter by an adversary. This mean that the cipher provided no guarantee to be tamper proof.
    If the ciphertext can be controlled by a user, it could be alter for arbitrary message in many cases.
</p>
<p>
    The solution is to used a cipher that include a HMAC. Combining a HMAC function to the existing cipher is prone to error <sup><a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/">[1]</a></sup>.
</p>
<p>
    <b>Code at risk:</b><br/>
    <i>AES in CBC mode</i><br/>

    <pre>Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
    <br/>
    <i>Triple DES with ECB mode</i><br/>

<pre>Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>

</p>
<p>
    <b>Solution:</b>
    <pre>Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<p>
    <b>References</b><br/>
    <a href="http://en.wikipedia.org/wiki/Authenticated_encryption">Wikipedia: Authenticated encryption</a><br/>
    <a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01">NIST: Authenticated Encryption Modes</a><br/>
    <a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/">Moxie Marlinspike's blog: The Cryptographic Doom Principle</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="CIPINT">Cipher with no integrity</BugCode>

    <!-- ESAPI Encryptor -->
    <Detector class="com.h3xstream.findsecbugs.crypto.EsapiEncryptorDetector">
        <Details>Identity usage of ESAPI Encryptor.</Details>
    </Detector>
    <BugPattern type="ESAPI_ENCRYPTOR">
        <ShortDescription>Usage of ESAPI Encryptor</ShortDescription>
        <LongDescription>The ESAPI encryptor API is use encrypt data</LongDescription>
        <Details>
<![CDATA[
<p>
    The ESAPI has a small history of vulnerabilities with the cryptography component. Here is a quick validation list to
    make sure the Authenticated Encryption is working as expected.
</p>
<p><b>1. Library Version</b></p>
<p>
    The latest version ESAPI is 1.2.0. Version <= 2.0.1 are vulnerable to a MAC bypass (CVE-2013-5679).<br/>
</p>
<p>
    For Maven users, the plugin <a href="http://mojo.codehaus.org/versions-maven-plugin/">versions</a> can called using the following command. The effective version of ESAPI will be available in the ouput.<br/>
    <pre>$ mvn versions:display-dependency-updates</pre>
    <br/>Output:<br/>
    <pre>
[...]
[INFO] The following dependencies in Dependencies have newer versions:
[INFO]   org.slf4j:slf4j-api ................................... 1.6.4 -> 1.7.7
[INFO]   org.owasp.esapi:esapi ................................. 2.0.1 -> 2.1.0
[...]
    </pre>
</p>
<p>
    or by looking at the configuration directly.<br/>
    <pre>
&lt;dependency&gt;
    &lt;groupId&gt;org.owasp.esapi&lt;/groupId&gt;
    &lt;artifactId&gt;esapi&lt;/artifactId&gt;
    &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;
    </pre>
</p>
<p>
    For Ant user, the jar used should be <a href="http://repo1.maven.org/maven2/org/owasp/esapi/esapi/2.1.0/esapi-2.1.0.jar">esapi-2.1.0.jar</a>.
</p>
<p><b>2. Configuration</b></p>
    <p>
    The library version 2.1.0 is still vulnerable to key size being change in the ciphertext definition (CVE-2013-5960). Some precautions need to be taken.<br/>
    <br/>
    <div><b>Vulnerable configuration (if any element are present)</b><br/>
    <pre>
Encryptor.CipherText.useMAC=false

Encryptor.EncryptionAlgorithm=AES
Encryptor.CipherTransformation=AES/CBC/PKCS5Padding

Encryptor.cipher_modes.additional_allowed=CBC</pre>
    </div>
</p>
<p>
    <div>
    <b>Secure configuration</b><br/>
    <pre>
#Needed
Encryptor.CipherText.useMAC=true

#Needed to have a solid auth. encryption
Encryptor.EncryptionAlgorithm=AES
Encryptor.CipherTransformation=AES/GCM/NoPadding

#CBC mode should be removed to avoid key size downgrade
Encryptor.cipher_modes.additional_allowed=</pre>
    </div>
</p>
<p>
    <b>References</b><br/>
    <a href="http://owasp-esapi-java.googlecode.com/svn/trunk/documentation/ESAPI-security-bulletin1.pdf">ESAPI Security bulletin 1 (CVE-2013-5679)</a><br/>
    <a href="http://www.synacktiv.com/ressources/synacktiv_owasp_esapi_hmac_bypass.pdf">Synactiv: Bypassing HMAC validation in OWASP ESAPI symmetric encryption</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="ESAPIENC">ESAPI Encryptor</BugCode>


</MessageCollection>
